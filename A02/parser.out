Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl
Rule 2     program -> <empty>
Rule 3     class_decl -> CLASS ID LBRACE class_body_decl RBRACE
Rule 4     class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
Rule 5     class_decl -> CLASS ID LBRACE class_body_decl RBRACE class_decl
Rule 6     class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl
Rule 7     class_body_decl -> field_decl
Rule 8     class_body_decl -> method_decl
Rule 9     class_body_decl -> constructor_decl
Rule 10    class_body_decl -> field_decl class_body_decl
Rule 11    class_body_decl -> method_decl class_body_decl
Rule 12    class_body_decl -> constructor_decl class_body_decl
Rule 13    field_decl -> modifier var_decl
Rule 14    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 15    method_decl -> modifier type ID LPAREN RPAREN block
Rule 16    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 17    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 18    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 19    constructor_decl -> modifier ID LPAREN RPAREN block
Rule 20    modifier -> PUBLIC STATIC
Rule 21    modifier -> PRIVATE STATIC
Rule 22    modifier -> PUBLIC
Rule 23    modifier -> PRIVATE
Rule 24    modifier -> STATIC
Rule 25    modifier -> <empty>
Rule 26    var_decl -> type variables SEMICOLON
Rule 27    type -> INT
Rule 28    type -> FLOAT
Rule 29    type -> BOOLEAN
Rule 30    type -> ID
Rule 31    variables -> variable
Rule 32    variables -> variable COMMA variables
Rule 33    variable -> ID
Rule 34    formals -> formal_param
Rule 35    formals -> formal_param COMMA formals
Rule 36    formal_param -> type variable
Rule 37    block -> LBRACE stmts RBRACE
Rule 38    stmts -> stmt
Rule 39    stmts -> stmt stmts
Rule 40    stmt -> IF LPAREN expr RPAREN stmt
Rule 41    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 42    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 43    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 44    stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
Rule 45    stmt -> RETURN expr SEMICOLON
Rule 46    stmt -> RETURN SEMICOLON
Rule 47    stmt -> stmt_expr SEMICOLON
Rule 48    stmt -> BREAK SEMICOLON
Rule 49    stmt -> CONTINUE SEMICOLON
Rule 50    stmt -> block
Rule 51    stmt -> var_decl
Rule 52    stmt -> SEMICOLON
Rule 53    stmt_expr -> assign
Rule 54    stmt_expr -> method_invocation
Rule 55    expr -> primary
Rule 56    expr -> assign
Rule 57    expr -> expr_arith_op
Rule 58    expr -> expr_bool_op
Rule 59    expr -> expr_unary_op
Rule 60    primary -> literal
Rule 61    primary -> THIS
Rule 62    primary -> SUPER
Rule 63    primary -> LPAREN expr RPAREN
Rule 64    primary -> NEW ID LPAREN arguments RPAREN
Rule 65    primary -> lhs
Rule 66    primary -> method_invocation
Rule 67    assign -> lhs EQUALS expr
Rule 68    assign -> lhs INCREMENT
Rule 69    assign -> INCREMENT lhs
Rule 70    assign -> lhs DECREMENT
Rule 71    assign -> DECREMENT lhs
Rule 72    lhs -> field_access
Rule 73    field_access -> primary DOT ID
Rule 74    field_access -> ID
Rule 75    arguments -> expr
Rule 76    arguments -> expr COMMA arguments
Rule 77    arguments -> <empty>
Rule 78    method_invocation -> field_access LPAREN arguments RPAREN
Rule 79    expr_arith_op -> expr arith_op expr
Rule 80    expr_bool_op -> expr bool_op expr
Rule 81    expr_unary_op -> PLUS expr
Rule 82    expr_unary_op -> MINUS expr
Rule 83    expr_unary_op -> NOT expr
Rule 84    literal -> INT_CONST
Rule 85    literal -> FLOAT_CONST
Rule 86    literal -> STRING_CONST
Rule 87    literal -> NULL
Rule 88    literal -> TRUE
Rule 89    literal -> FALSE
Rule 90    arith_op -> PLUS
Rule 91    arith_op -> MINUS
Rule 92    arith_op -> TIMES
Rule 93    arith_op -> DIVIDE
Rule 94    bool_op -> AND
Rule 95    bool_op -> OR
Rule 96    bool_op -> EQ
Rule 97    bool_op -> NE
Rule 98    bool_op -> LT
Rule 99    bool_op -> GT
Rule 100   bool_op -> LE
Rule 101   bool_op -> GE

Terminals, with rules where they appear

AND                  : 94
BOOLEAN              : 29
BREAK                : 48
CLASS                : 3 4 5 6
COMMA                : 32 35 76
CONTINUE             : 49
DECREMENT            : 70 71
DIVIDE               : 93
DOT                  : 73
ELSE                 : 41
EQ                   : 96
EQUALS               : 67
EXTENDS              : 4 6
FALSE                : 89
FLOAT                : 28
FLOAT_CONST          : 85
FOR                  : 43 44
GE                   : 101
GT                   : 99
ID                   : 3 4 4 5 6 6 14 15 16 17 18 19 30 33 64 73 74
IF                   : 40 41
INCREMENT            : 68 69
INT                  : 27
INT_CONST            : 84
LBRACE               : 3 4 5 6 37
LE                   : 100
LPAREN               : 14 15 16 17 18 19 40 41 42 43 44 63 64 78
LT                   : 98
MINUS                : 82 91
NE                   : 97
NEW                  : 64
NOT                  : 83
NULL                 : 87
OR                   : 95
PLUS                 : 81 90
PRIVATE              : 21 23
PUBLIC               : 20 22
RBRACE               : 3 4 5 6 37
RETURN               : 45 46
RPAREN               : 14 15 16 17 18 19 40 41 42 43 44 63 64 78
SEMICOLON            : 26 43 43 44 44 45 46 47 48 49 52
STATIC               : 20 21 24
STRING_CONST         : 86
SUPER                : 62
THIS                 : 61
TIMES                : 92
TRUE                 : 88
VOID                 : 16 17
WHILE                : 42
error                : 

Nonterminals, with rules where they appear

arguments            : 64 76 78
arith_op             : 79
assign               : 53 56
block                : 14 15 16 17 18 19 50
bool_op              : 80
class_body_decl      : 3 4 5 6 10 11 12
class_decl           : 1 5 6
constructor_decl     : 9 12
expr                 : 40 41 42 43 45 63 67 75 76 79 79 80 80 81 82 83
expr_arith_op        : 57
expr_bool_op         : 58
expr_unary_op        : 59
field_access         : 72 78
field_decl           : 7 10
formal_param         : 34 35
formals              : 14 16 18 35
lhs                  : 65 67 68 69 70 71
literal              : 60
method_decl          : 8 11
method_invocation    : 54 66
modifier             : 13 14 15 16 17 18 19
primary              : 55 73
program              : 0
stmt                 : 38 39 40 41 41 42 43 44
stmt_expr            : 43 43 47
stmts                : 37 39
type                 : 14 15 26 36
var_decl             : 13 51
variable             : 31 32 36
variables            : 26 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl
    (2) program -> .
    (3) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE
    (4) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE class_decl
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl

    $end            reduce using rule 2 (program -> .)
    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> class_decl .

    $end            reduce using rule 1 (program -> class_decl .)


state 3

    (3) class_decl -> CLASS . ID LBRACE class_body_decl RBRACE
    (4) class_decl -> CLASS . ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> CLASS . ID LBRACE class_body_decl RBRACE class_decl
    (6) class_decl -> CLASS . ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl

    ID              shift and go to state 4


state 4

    (3) class_decl -> CLASS ID . LBRACE class_body_decl RBRACE
    (4) class_decl -> CLASS ID . EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> CLASS ID . LBRACE class_body_decl RBRACE class_decl
    (6) class_decl -> CLASS ID . EXTENDS ID LBRACE class_body_decl RBRACE class_decl

    LBRACE          shift and go to state 5
    EXTENDS         shift and go to state 6


state 5

    (3) class_decl -> CLASS ID LBRACE . class_body_decl RBRACE
    (5) class_decl -> CLASS ID LBRACE . class_body_decl RBRACE class_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) class_body_decl -> . field_decl class_body_decl
    (11) class_body_decl -> . method_decl class_body_decl
    (12) class_body_decl -> . constructor_decl class_body_decl
    (13) field_decl -> . modifier var_decl
    (14) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (15) method_decl -> . modifier type ID LPAREN RPAREN block
    (16) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (17) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (18) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (19) constructor_decl -> . modifier ID LPAREN RPAREN block
    (20) modifier -> . PUBLIC STATIC
    (21) modifier -> . PRIVATE STATIC
    (22) modifier -> . PUBLIC
    (23) modifier -> . PRIVATE
    (24) modifier -> . STATIC
    (25) modifier -> .

    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 25 (modifier -> .)
    ID              reduce using rule 25 (modifier -> .)
    INT             reduce using rule 25 (modifier -> .)
    FLOAT           reduce using rule 25 (modifier -> .)
    BOOLEAN         reduce using rule 25 (modifier -> .)

    class_body_decl                shift and go to state 7
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11

state 6

    (4) class_decl -> CLASS ID EXTENDS . ID LBRACE class_body_decl RBRACE
    (6) class_decl -> CLASS ID EXTENDS . ID LBRACE class_body_decl RBRACE class_decl

    ID              shift and go to state 15


state 7

    (3) class_decl -> CLASS ID LBRACE class_body_decl . RBRACE
    (5) class_decl -> CLASS ID LBRACE class_body_decl . RBRACE class_decl

    RBRACE          shift and go to state 16


state 8

    (7) class_body_decl -> field_decl .
    (10) class_body_decl -> field_decl . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) class_body_decl -> . field_decl class_body_decl
    (11) class_body_decl -> . method_decl class_body_decl
    (12) class_body_decl -> . constructor_decl class_body_decl
    (13) field_decl -> . modifier var_decl
    (14) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (15) method_decl -> . modifier type ID LPAREN RPAREN block
    (16) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (17) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (18) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (19) constructor_decl -> . modifier ID LPAREN RPAREN block
    (20) modifier -> . PUBLIC STATIC
    (21) modifier -> . PRIVATE STATIC
    (22) modifier -> . PUBLIC
    (23) modifier -> . PRIVATE
    (24) modifier -> . STATIC
    (25) modifier -> .

    RBRACE          reduce using rule 7 (class_body_decl -> field_decl .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 25 (modifier -> .)
    ID              reduce using rule 25 (modifier -> .)
    INT             reduce using rule 25 (modifier -> .)
    FLOAT           reduce using rule 25 (modifier -> .)
    BOOLEAN         reduce using rule 25 (modifier -> .)

    field_decl                     shift and go to state 8
    class_body_decl                shift and go to state 17
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11

state 9

    (8) class_body_decl -> method_decl .
    (11) class_body_decl -> method_decl . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) class_body_decl -> . field_decl class_body_decl
    (11) class_body_decl -> . method_decl class_body_decl
    (12) class_body_decl -> . constructor_decl class_body_decl
    (13) field_decl -> . modifier var_decl
    (14) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (15) method_decl -> . modifier type ID LPAREN RPAREN block
    (16) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (17) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (18) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (19) constructor_decl -> . modifier ID LPAREN RPAREN block
    (20) modifier -> . PUBLIC STATIC
    (21) modifier -> . PRIVATE STATIC
    (22) modifier -> . PUBLIC
    (23) modifier -> . PRIVATE
    (24) modifier -> . STATIC
    (25) modifier -> .

    RBRACE          reduce using rule 8 (class_body_decl -> method_decl .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 25 (modifier -> .)
    ID              reduce using rule 25 (modifier -> .)
    INT             reduce using rule 25 (modifier -> .)
    FLOAT           reduce using rule 25 (modifier -> .)
    BOOLEAN         reduce using rule 25 (modifier -> .)

    method_decl                    shift and go to state 9
    class_body_decl                shift and go to state 18
    field_decl                     shift and go to state 8
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11

state 10

    (9) class_body_decl -> constructor_decl .
    (12) class_body_decl -> constructor_decl . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) class_body_decl -> . field_decl class_body_decl
    (11) class_body_decl -> . method_decl class_body_decl
    (12) class_body_decl -> . constructor_decl class_body_decl
    (13) field_decl -> . modifier var_decl
    (14) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (15) method_decl -> . modifier type ID LPAREN RPAREN block
    (16) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (17) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (18) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (19) constructor_decl -> . modifier ID LPAREN RPAREN block
    (20) modifier -> . PUBLIC STATIC
    (21) modifier -> . PRIVATE STATIC
    (22) modifier -> . PUBLIC
    (23) modifier -> . PRIVATE
    (24) modifier -> . STATIC
    (25) modifier -> .

    RBRACE          reduce using rule 9 (class_body_decl -> constructor_decl .)
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 25 (modifier -> .)
    ID              reduce using rule 25 (modifier -> .)
    INT             reduce using rule 25 (modifier -> .)
    FLOAT           reduce using rule 25 (modifier -> .)
    BOOLEAN         reduce using rule 25 (modifier -> .)

    constructor_decl               shift and go to state 10
    class_body_decl                shift and go to state 19
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    modifier                       shift and go to state 11

state 11

    (13) field_decl -> modifier . var_decl
    (14) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (15) method_decl -> modifier . type ID LPAREN RPAREN block
    (16) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (17) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (18) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (19) constructor_decl -> modifier . ID LPAREN RPAREN block
    (26) var_decl -> . type variables SEMICOLON
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID

    VOID            shift and go to state 23
    ID              shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26

    var_decl                       shift and go to state 20
    type                           shift and go to state 21

state 12

    (20) modifier -> PUBLIC . STATIC
    (22) modifier -> PUBLIC .

    STATIC          shift and go to state 27
    VOID            reduce using rule 22 (modifier -> PUBLIC .)
    ID              reduce using rule 22 (modifier -> PUBLIC .)
    INT             reduce using rule 22 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 22 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 22 (modifier -> PUBLIC .)


state 13

    (24) modifier -> STATIC .

    VOID            reduce using rule 24 (modifier -> STATIC .)
    ID              reduce using rule 24 (modifier -> STATIC .)
    INT             reduce using rule 24 (modifier -> STATIC .)
    FLOAT           reduce using rule 24 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 24 (modifier -> STATIC .)


state 14

    (21) modifier -> PRIVATE . STATIC
    (23) modifier -> PRIVATE .

    STATIC          shift and go to state 28
    VOID            reduce using rule 23 (modifier -> PRIVATE .)
    ID              reduce using rule 23 (modifier -> PRIVATE .)
    INT             reduce using rule 23 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 23 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 23 (modifier -> PRIVATE .)


state 15

    (4) class_decl -> CLASS ID EXTENDS ID . LBRACE class_body_decl RBRACE
    (6) class_decl -> CLASS ID EXTENDS ID . LBRACE class_body_decl RBRACE class_decl

    LBRACE          shift and go to state 29


state 16

    (3) class_decl -> CLASS ID LBRACE class_body_decl RBRACE .
    (5) class_decl -> CLASS ID LBRACE class_body_decl RBRACE . class_decl
    (3) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE
    (4) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE class_decl
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl

    $end            reduce using rule 3 (class_decl -> CLASS ID LBRACE class_body_decl RBRACE .)
    CLASS           shift and go to state 3

    class_decl                     shift and go to state 30

state 17

    (10) class_body_decl -> field_decl class_body_decl .

    RBRACE          reduce using rule 10 (class_body_decl -> field_decl class_body_decl .)


state 18

    (11) class_body_decl -> method_decl class_body_decl .

    RBRACE          reduce using rule 11 (class_body_decl -> method_decl class_body_decl .)


state 19

    (12) class_body_decl -> constructor_decl class_body_decl .

    RBRACE          reduce using rule 12 (class_body_decl -> constructor_decl class_body_decl .)


state 20

    (13) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 13 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 13 (field_decl -> modifier var_decl .)
    ID              reduce using rule 13 (field_decl -> modifier var_decl .)
    INT             reduce using rule 13 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> modifier var_decl .)
    RBRACE          reduce using rule 13 (field_decl -> modifier var_decl .)


state 21

    (14) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (15) method_decl -> modifier type . ID LPAREN RPAREN block
    (26) var_decl -> type . variables SEMICOLON
    (31) variables -> . variable
    (32) variables -> . variable COMMA variables
    (33) variable -> . ID

    ID              shift and go to state 31

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 22

    (18) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (19) constructor_decl -> modifier ID . LPAREN RPAREN block
    (30) type -> ID .

    LPAREN          shift and go to state 34
    ID              reduce using rule 30 (type -> ID .)


state 23

    (16) method_decl -> modifier VOID . ID LPAREN formals RPAREN block
    (17) method_decl -> modifier VOID . ID LPAREN RPAREN block

    ID              shift and go to state 35


state 24

    (27) type -> INT .

    ID              reduce using rule 27 (type -> INT .)


state 25

    (28) type -> FLOAT .

    ID              reduce using rule 28 (type -> FLOAT .)


state 26

    (29) type -> BOOLEAN .

    ID              reduce using rule 29 (type -> BOOLEAN .)


state 27

    (20) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 20 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 20 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 20 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 20 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 20 (modifier -> PUBLIC STATIC .)


state 28

    (21) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 21 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 21 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 21 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 21 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 21 (modifier -> PRIVATE STATIC .)


state 29

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE . class_body_decl RBRACE
    (6) class_decl -> CLASS ID EXTENDS ID LBRACE . class_body_decl RBRACE class_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) class_body_decl -> . field_decl class_body_decl
    (11) class_body_decl -> . method_decl class_body_decl
    (12) class_body_decl -> . constructor_decl class_body_decl
    (13) field_decl -> . modifier var_decl
    (14) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (15) method_decl -> . modifier type ID LPAREN RPAREN block
    (16) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (17) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (18) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (19) constructor_decl -> . modifier ID LPAREN RPAREN block
    (20) modifier -> . PUBLIC STATIC
    (21) modifier -> . PRIVATE STATIC
    (22) modifier -> . PUBLIC
    (23) modifier -> . PRIVATE
    (24) modifier -> . STATIC
    (25) modifier -> .

    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 14
    STATIC          shift and go to state 13
    VOID            reduce using rule 25 (modifier -> .)
    ID              reduce using rule 25 (modifier -> .)
    INT             reduce using rule 25 (modifier -> .)
    FLOAT           reduce using rule 25 (modifier -> .)
    BOOLEAN         reduce using rule 25 (modifier -> .)

    class_body_decl                shift and go to state 36
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11

state 30

    (5) class_decl -> CLASS ID LBRACE class_body_decl RBRACE class_decl .

    $end            reduce using rule 5 (class_decl -> CLASS ID LBRACE class_body_decl RBRACE class_decl .)


state 31

    (14) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (15) method_decl -> modifier type ID . LPAREN RPAREN block
    (33) variable -> ID .

    LPAREN          shift and go to state 37
    COMMA           reduce using rule 33 (variable -> ID .)
    SEMICOLON       reduce using rule 33 (variable -> ID .)


state 32

    (26) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 38


state 33

    (31) variables -> variable .
    (32) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 31 (variables -> variable .)
    COMMA           shift and go to state 39


state 34

    (18) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (19) constructor_decl -> modifier ID LPAREN . RPAREN block
    (34) formals -> . formal_param
    (35) formals -> . formal_param COMMA formals
    (36) formal_param -> . type variable
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID

    RPAREN          shift and go to state 42
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 40

    formals                        shift and go to state 41
    formal_param                   shift and go to state 43
    type                           shift and go to state 44

state 35

    (16) method_decl -> modifier VOID ID . LPAREN formals RPAREN block
    (17) method_decl -> modifier VOID ID . LPAREN RPAREN block

    LPAREN          shift and go to state 45


state 36

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl . RBRACE
    (6) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl . RBRACE class_decl

    RBRACE          shift and go to state 46


state 37

    (14) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (15) method_decl -> modifier type ID LPAREN . RPAREN block
    (34) formals -> . formal_param
    (35) formals -> . formal_param COMMA formals
    (36) formal_param -> . type variable
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID

    RPAREN          shift and go to state 48
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 40

    type                           shift and go to state 44
    formals                        shift and go to state 47
    formal_param                   shift and go to state 43

state 38

    (26) var_decl -> type variables SEMICOLON .

    PUBLIC          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    RBRACE          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    LBRACE          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INCREMENT       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    DECREMENT       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 26 (var_decl -> type variables SEMICOLON .)


state 39

    (32) variables -> variable COMMA . variables
    (31) variables -> . variable
    (32) variables -> . variable COMMA variables
    (33) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 33
    variables                      shift and go to state 49

state 40

    (30) type -> ID .

    ID              reduce using rule 30 (type -> ID .)


state 41

    (18) constructor_decl -> modifier ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 51


state 42

    (19) constructor_decl -> modifier ID LPAREN RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 52

state 43

    (34) formals -> formal_param .
    (35) formals -> formal_param . COMMA formals

    RPAREN          reduce using rule 34 (formals -> formal_param .)
    COMMA           shift and go to state 54


state 44

    (36) formal_param -> type . variable
    (33) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 55

state 45

    (16) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (17) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (34) formals -> . formal_param
    (35) formals -> . formal_param COMMA formals
    (36) formal_param -> . type variable
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID

    RPAREN          shift and go to state 57
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 40

    formals                        shift and go to state 56
    formal_param                   shift and go to state 43
    type                           shift and go to state 44

state 46

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE .
    (6) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE . class_decl
    (3) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE
    (4) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE class_decl
    (6) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl

    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE .)
    CLASS           shift and go to state 3

    class_decl                     shift and go to state 58

state 47

    (14) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 59


state 48

    (15) method_decl -> modifier type ID LPAREN RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 60

state 49

    (32) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 32 (variables -> variable COMMA variables .)


state 50

    (33) variable -> ID .

    COMMA           reduce using rule 33 (variable -> ID .)
    SEMICOLON       reduce using rule 33 (variable -> ID .)
    RPAREN          reduce using rule 33 (variable -> ID .)


state 51

    (18) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 61

state 52

    (19) constructor_decl -> modifier ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STATIC          reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    VOID            reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    ID              reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    INT             reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 19 (constructor_decl -> modifier ID LPAREN RPAREN block .)


state 53

    (37) block -> LBRACE . stmts RBRACE
    (38) stmts -> . stmt
    (39) stmts -> . stmt stmts
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmts                          shift and go to state 62
    stmt                           shift and go to state 63
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 54

    (35) formals -> formal_param COMMA . formals
    (34) formals -> . formal_param
    (35) formals -> . formal_param COMMA formals
    (36) formal_param -> . type variable
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID

    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 40

    formal_param                   shift and go to state 43
    formals                        shift and go to state 94
    type                           shift and go to state 44

state 55

    (36) formal_param -> type variable .

    COMMA           reduce using rule 36 (formal_param -> type variable .)
    RPAREN          reduce using rule 36 (formal_param -> type variable .)


state 56

    (16) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 95


state 57

    (17) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 96

state 58

    (6) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl .

    $end            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE class_decl .)


state 59

    (14) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 97

state 60

    (15) method_decl -> modifier type ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    STATIC          reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 15 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 61

    (18) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 18 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 62

    (37) block -> LBRACE stmts . RBRACE

    RBRACE          shift and go to state 98


state 63

    (38) stmts -> stmt .
    (39) stmts -> stmt . stmts
    (38) stmts -> . stmt
    (39) stmts -> . stmt stmts
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    RBRACE          reduce using rule 38 (stmts -> stmt .)
    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt                           shift and go to state 63
    stmts                          shift and go to state 99
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 64

    (40) stmt -> IF . LPAREN expr RPAREN stmt
    (41) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 100


state 65

    (63) primary -> LPAREN . expr RPAREN
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 101
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 66

    (42) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 114


state 67

    (43) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> FOR . LPAREN SEMICOLON SEMICOLON RPAREN stmt

    LPAREN          shift and go to state 115


state 68

    (47) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 116


state 69

    (52) stmt -> SEMICOLON .

    IF              reduce using rule 52 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 52 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 52 (stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 52 (stmt -> SEMICOLON .)
    DECREMENT       reduce using rule 52 (stmt -> SEMICOLON .)
    INT             reduce using rule 52 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> SEMICOLON .)
    ID              reduce using rule 52 (stmt -> SEMICOLON .)
    THIS            reduce using rule 52 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 52 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 52 (stmt -> SEMICOLON .)
    NEW             reduce using rule 52 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 52 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 52 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 52 (stmt -> SEMICOLON .)
    NULL            reduce using rule 52 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 52 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 52 (stmt -> SEMICOLON .)
    RBRACE          reduce using rule 52 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> SEMICOLON .)


state 70

    (45) stmt -> RETURN . expr SEMICOLON
    (46) stmt -> RETURN . SEMICOLON
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    SEMICOLON       shift and go to state 118
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 117
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 71

    (48) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 119


state 72

    (49) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 120


state 73

    (50) stmt -> block .

    IF              reduce using rule 50 (stmt -> block .)
    WHILE           reduce using rule 50 (stmt -> block .)
    FOR             reduce using rule 50 (stmt -> block .)
    RETURN          reduce using rule 50 (stmt -> block .)
    BREAK           reduce using rule 50 (stmt -> block .)
    CONTINUE        reduce using rule 50 (stmt -> block .)
    SEMICOLON       reduce using rule 50 (stmt -> block .)
    LBRACE          reduce using rule 50 (stmt -> block .)
    INCREMENT       reduce using rule 50 (stmt -> block .)
    DECREMENT       reduce using rule 50 (stmt -> block .)
    INT             reduce using rule 50 (stmt -> block .)
    FLOAT           reduce using rule 50 (stmt -> block .)
    BOOLEAN         reduce using rule 50 (stmt -> block .)
    ID              reduce using rule 50 (stmt -> block .)
    THIS            reduce using rule 50 (stmt -> block .)
    SUPER           reduce using rule 50 (stmt -> block .)
    LPAREN          reduce using rule 50 (stmt -> block .)
    NEW             reduce using rule 50 (stmt -> block .)
    INT_CONST       reduce using rule 50 (stmt -> block .)
    FLOAT_CONST     reduce using rule 50 (stmt -> block .)
    STRING_CONST    reduce using rule 50 (stmt -> block .)
    NULL            reduce using rule 50 (stmt -> block .)
    TRUE            reduce using rule 50 (stmt -> block .)
    FALSE           reduce using rule 50 (stmt -> block .)
    RBRACE          reduce using rule 50 (stmt -> block .)
    ELSE            reduce using rule 50 (stmt -> block .)


state 74

    (51) stmt -> var_decl .

    IF              reduce using rule 51 (stmt -> var_decl .)
    WHILE           reduce using rule 51 (stmt -> var_decl .)
    FOR             reduce using rule 51 (stmt -> var_decl .)
    RETURN          reduce using rule 51 (stmt -> var_decl .)
    BREAK           reduce using rule 51 (stmt -> var_decl .)
    CONTINUE        reduce using rule 51 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 51 (stmt -> var_decl .)
    LBRACE          reduce using rule 51 (stmt -> var_decl .)
    INCREMENT       reduce using rule 51 (stmt -> var_decl .)
    DECREMENT       reduce using rule 51 (stmt -> var_decl .)
    INT             reduce using rule 51 (stmt -> var_decl .)
    FLOAT           reduce using rule 51 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 51 (stmt -> var_decl .)
    ID              reduce using rule 51 (stmt -> var_decl .)
    THIS            reduce using rule 51 (stmt -> var_decl .)
    SUPER           reduce using rule 51 (stmt -> var_decl .)
    LPAREN          reduce using rule 51 (stmt -> var_decl .)
    NEW             reduce using rule 51 (stmt -> var_decl .)
    INT_CONST       reduce using rule 51 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 51 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 51 (stmt -> var_decl .)
    NULL            reduce using rule 51 (stmt -> var_decl .)
    TRUE            reduce using rule 51 (stmt -> var_decl .)
    FALSE           reduce using rule 51 (stmt -> var_decl .)
    RBRACE          reduce using rule 51 (stmt -> var_decl .)
    ELSE            reduce using rule 51 (stmt -> var_decl .)


state 75

    (53) stmt_expr -> assign .

    SEMICOLON       reduce using rule 53 (stmt_expr -> assign .)
    RPAREN          reduce using rule 53 (stmt_expr -> assign .)


state 76

    (54) stmt_expr -> method_invocation .
    (66) primary -> method_invocation .

    SEMICOLON       reduce using rule 54 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 54 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 66 (primary -> method_invocation .)


state 77

    (26) var_decl -> type . variables SEMICOLON
    (31) variables -> . variable
    (32) variables -> . variable COMMA variables
    (33) variable -> . ID

    ID              shift and go to state 50

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 78

    (67) assign -> lhs . EQUALS expr
    (68) assign -> lhs . INCREMENT
    (70) assign -> lhs . DECREMENT
    (65) primary -> lhs .

    EQUALS          shift and go to state 121
    INCREMENT       shift and go to state 122
    DECREMENT       shift and go to state 123
    DOT             reduce using rule 65 (primary -> lhs .)


state 79

    (69) assign -> INCREMENT . lhs
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (78) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 107
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    lhs                            shift and go to state 124
    field_access                   shift and go to state 113
    primary                        shift and go to state 83
    literal                        shift and go to state 84
    method_invocation              shift and go to state 109

state 80

    (71) assign -> DECREMENT . lhs
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (78) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 107
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    lhs                            shift and go to state 125
    field_access                   shift and go to state 113
    primary                        shift and go to state 83
    literal                        shift and go to state 84
    method_invocation              shift and go to state 109

state 81

    (78) method_invocation -> field_access . LPAREN arguments RPAREN
    (72) lhs -> field_access .

    LPAREN          shift and go to state 126
    EQUALS          reduce using rule 72 (lhs -> field_access .)
    INCREMENT       reduce using rule 72 (lhs -> field_access .)
    DECREMENT       reduce using rule 72 (lhs -> field_access .)
    DOT             reduce using rule 72 (lhs -> field_access .)


state 82

    (30) type -> ID .
    (74) field_access -> ID .

    ID              reduce using rule 30 (type -> ID .)
    LPAREN          reduce using rule 74 (field_access -> ID .)
    EQUALS          reduce using rule 74 (field_access -> ID .)
    INCREMENT       reduce using rule 74 (field_access -> ID .)
    DECREMENT       reduce using rule 74 (field_access -> ID .)
    DOT             reduce using rule 74 (field_access -> ID .)


state 83

    (73) field_access -> primary . DOT ID

    DOT             shift and go to state 127


state 84

    (60) primary -> literal .

    DOT             reduce using rule 60 (primary -> literal .)
    RPAREN          reduce using rule 60 (primary -> literal .)
    PLUS            reduce using rule 60 (primary -> literal .)
    MINUS           reduce using rule 60 (primary -> literal .)
    TIMES           reduce using rule 60 (primary -> literal .)
    DIVIDE          reduce using rule 60 (primary -> literal .)
    AND             reduce using rule 60 (primary -> literal .)
    OR              reduce using rule 60 (primary -> literal .)
    EQ              reduce using rule 60 (primary -> literal .)
    NE              reduce using rule 60 (primary -> literal .)
    LT              reduce using rule 60 (primary -> literal .)
    GT              reduce using rule 60 (primary -> literal .)
    LE              reduce using rule 60 (primary -> literal .)
    GE              reduce using rule 60 (primary -> literal .)
    SEMICOLON       reduce using rule 60 (primary -> literal .)
    COMMA           reduce using rule 60 (primary -> literal .)


state 85

    (61) primary -> THIS .

    DOT             reduce using rule 61 (primary -> THIS .)
    RPAREN          reduce using rule 61 (primary -> THIS .)
    PLUS            reduce using rule 61 (primary -> THIS .)
    MINUS           reduce using rule 61 (primary -> THIS .)
    TIMES           reduce using rule 61 (primary -> THIS .)
    DIVIDE          reduce using rule 61 (primary -> THIS .)
    AND             reduce using rule 61 (primary -> THIS .)
    OR              reduce using rule 61 (primary -> THIS .)
    EQ              reduce using rule 61 (primary -> THIS .)
    NE              reduce using rule 61 (primary -> THIS .)
    LT              reduce using rule 61 (primary -> THIS .)
    GT              reduce using rule 61 (primary -> THIS .)
    LE              reduce using rule 61 (primary -> THIS .)
    GE              reduce using rule 61 (primary -> THIS .)
    SEMICOLON       reduce using rule 61 (primary -> THIS .)
    COMMA           reduce using rule 61 (primary -> THIS .)


state 86

    (62) primary -> SUPER .

    DOT             reduce using rule 62 (primary -> SUPER .)
    RPAREN          reduce using rule 62 (primary -> SUPER .)
    PLUS            reduce using rule 62 (primary -> SUPER .)
    MINUS           reduce using rule 62 (primary -> SUPER .)
    TIMES           reduce using rule 62 (primary -> SUPER .)
    DIVIDE          reduce using rule 62 (primary -> SUPER .)
    AND             reduce using rule 62 (primary -> SUPER .)
    OR              reduce using rule 62 (primary -> SUPER .)
    EQ              reduce using rule 62 (primary -> SUPER .)
    NE              reduce using rule 62 (primary -> SUPER .)
    LT              reduce using rule 62 (primary -> SUPER .)
    GT              reduce using rule 62 (primary -> SUPER .)
    LE              reduce using rule 62 (primary -> SUPER .)
    GE              reduce using rule 62 (primary -> SUPER .)
    SEMICOLON       reduce using rule 62 (primary -> SUPER .)
    COMMA           reduce using rule 62 (primary -> SUPER .)


state 87

    (64) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 128


state 88

    (84) literal -> INT_CONST .

    DOT             reduce using rule 84 (literal -> INT_CONST .)
    RPAREN          reduce using rule 84 (literal -> INT_CONST .)
    PLUS            reduce using rule 84 (literal -> INT_CONST .)
    MINUS           reduce using rule 84 (literal -> INT_CONST .)
    TIMES           reduce using rule 84 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 84 (literal -> INT_CONST .)
    AND             reduce using rule 84 (literal -> INT_CONST .)
    OR              reduce using rule 84 (literal -> INT_CONST .)
    EQ              reduce using rule 84 (literal -> INT_CONST .)
    NE              reduce using rule 84 (literal -> INT_CONST .)
    LT              reduce using rule 84 (literal -> INT_CONST .)
    GT              reduce using rule 84 (literal -> INT_CONST .)
    LE              reduce using rule 84 (literal -> INT_CONST .)
    GE              reduce using rule 84 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 84 (literal -> INT_CONST .)
    COMMA           reduce using rule 84 (literal -> INT_CONST .)


state 89

    (85) literal -> FLOAT_CONST .

    DOT             reduce using rule 85 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 85 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 85 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 85 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 85 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 85 (literal -> FLOAT_CONST .)
    AND             reduce using rule 85 (literal -> FLOAT_CONST .)
    OR              reduce using rule 85 (literal -> FLOAT_CONST .)
    EQ              reduce using rule 85 (literal -> FLOAT_CONST .)
    NE              reduce using rule 85 (literal -> FLOAT_CONST .)
    LT              reduce using rule 85 (literal -> FLOAT_CONST .)
    GT              reduce using rule 85 (literal -> FLOAT_CONST .)
    LE              reduce using rule 85 (literal -> FLOAT_CONST .)
    GE              reduce using rule 85 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 85 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 85 (literal -> FLOAT_CONST .)


state 90

    (86) literal -> STRING_CONST .

    DOT             reduce using rule 86 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 86 (literal -> STRING_CONST .)
    PLUS            reduce using rule 86 (literal -> STRING_CONST .)
    MINUS           reduce using rule 86 (literal -> STRING_CONST .)
    TIMES           reduce using rule 86 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 86 (literal -> STRING_CONST .)
    AND             reduce using rule 86 (literal -> STRING_CONST .)
    OR              reduce using rule 86 (literal -> STRING_CONST .)
    EQ              reduce using rule 86 (literal -> STRING_CONST .)
    NE              reduce using rule 86 (literal -> STRING_CONST .)
    LT              reduce using rule 86 (literal -> STRING_CONST .)
    GT              reduce using rule 86 (literal -> STRING_CONST .)
    LE              reduce using rule 86 (literal -> STRING_CONST .)
    GE              reduce using rule 86 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 86 (literal -> STRING_CONST .)
    COMMA           reduce using rule 86 (literal -> STRING_CONST .)


state 91

    (87) literal -> NULL .

    DOT             reduce using rule 87 (literal -> NULL .)
    RPAREN          reduce using rule 87 (literal -> NULL .)
    PLUS            reduce using rule 87 (literal -> NULL .)
    MINUS           reduce using rule 87 (literal -> NULL .)
    TIMES           reduce using rule 87 (literal -> NULL .)
    DIVIDE          reduce using rule 87 (literal -> NULL .)
    AND             reduce using rule 87 (literal -> NULL .)
    OR              reduce using rule 87 (literal -> NULL .)
    EQ              reduce using rule 87 (literal -> NULL .)
    NE              reduce using rule 87 (literal -> NULL .)
    LT              reduce using rule 87 (literal -> NULL .)
    GT              reduce using rule 87 (literal -> NULL .)
    LE              reduce using rule 87 (literal -> NULL .)
    GE              reduce using rule 87 (literal -> NULL .)
    SEMICOLON       reduce using rule 87 (literal -> NULL .)
    COMMA           reduce using rule 87 (literal -> NULL .)


state 92

    (88) literal -> TRUE .

    DOT             reduce using rule 88 (literal -> TRUE .)
    RPAREN          reduce using rule 88 (literal -> TRUE .)
    PLUS            reduce using rule 88 (literal -> TRUE .)
    MINUS           reduce using rule 88 (literal -> TRUE .)
    TIMES           reduce using rule 88 (literal -> TRUE .)
    DIVIDE          reduce using rule 88 (literal -> TRUE .)
    AND             reduce using rule 88 (literal -> TRUE .)
    OR              reduce using rule 88 (literal -> TRUE .)
    EQ              reduce using rule 88 (literal -> TRUE .)
    NE              reduce using rule 88 (literal -> TRUE .)
    LT              reduce using rule 88 (literal -> TRUE .)
    GT              reduce using rule 88 (literal -> TRUE .)
    LE              reduce using rule 88 (literal -> TRUE .)
    GE              reduce using rule 88 (literal -> TRUE .)
    SEMICOLON       reduce using rule 88 (literal -> TRUE .)
    COMMA           reduce using rule 88 (literal -> TRUE .)


state 93

    (89) literal -> FALSE .

    DOT             reduce using rule 89 (literal -> FALSE .)
    RPAREN          reduce using rule 89 (literal -> FALSE .)
    PLUS            reduce using rule 89 (literal -> FALSE .)
    MINUS           reduce using rule 89 (literal -> FALSE .)
    TIMES           reduce using rule 89 (literal -> FALSE .)
    DIVIDE          reduce using rule 89 (literal -> FALSE .)
    AND             reduce using rule 89 (literal -> FALSE .)
    OR              reduce using rule 89 (literal -> FALSE .)
    EQ              reduce using rule 89 (literal -> FALSE .)
    NE              reduce using rule 89 (literal -> FALSE .)
    LT              reduce using rule 89 (literal -> FALSE .)
    GT              reduce using rule 89 (literal -> FALSE .)
    LE              reduce using rule 89 (literal -> FALSE .)
    GE              reduce using rule 89 (literal -> FALSE .)
    SEMICOLON       reduce using rule 89 (literal -> FALSE .)
    COMMA           reduce using rule 89 (literal -> FALSE .)


state 94

    (35) formals -> formal_param COMMA formals .

    RPAREN          reduce using rule 35 (formals -> formal_param COMMA formals .)


state 95

    (16) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (37) block -> . LBRACE stmts RBRACE

    LBRACE          shift and go to state 53

    block                          shift and go to state 129

state 96

    (17) method_decl -> modifier VOID ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    STATIC          reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 17 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 97

    (14) method_decl -> modifier type ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 14 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 98

    (37) block -> LBRACE stmts RBRACE .

    PUBLIC          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    PRIVATE         reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    STATIC          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    VOID            reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    ID              reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    INT             reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    FLOAT           reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    BOOLEAN         reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    RBRACE          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    IF              reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    WHILE           reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    FOR             reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    RETURN          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    BREAK           reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    CONTINUE        reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    SEMICOLON       reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    LBRACE          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    INCREMENT       reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    DECREMENT       reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    THIS            reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    SUPER           reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    LPAREN          reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    NEW             reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    INT_CONST       reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    FLOAT_CONST     reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    STRING_CONST    reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    NULL            reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    TRUE            reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    FALSE           reduce using rule 37 (block -> LBRACE stmts RBRACE .)
    ELSE            reduce using rule 37 (block -> LBRACE stmts RBRACE .)


state 99

    (39) stmts -> stmt stmts .

    RBRACE          reduce using rule 39 (stmts -> stmt stmts .)


state 100

    (40) stmt -> IF LPAREN . expr RPAREN stmt
    (41) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 130
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 101

    (63) primary -> LPAREN expr . RPAREN
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          shift and go to state 131
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 102

    (55) expr -> primary .
    (73) field_access -> primary . DOT ID

    RPAREN          reduce using rule 55 (expr -> primary .)
    PLUS            reduce using rule 55 (expr -> primary .)
    MINUS           reduce using rule 55 (expr -> primary .)
    TIMES           reduce using rule 55 (expr -> primary .)
    DIVIDE          reduce using rule 55 (expr -> primary .)
    AND             reduce using rule 55 (expr -> primary .)
    OR              reduce using rule 55 (expr -> primary .)
    EQ              reduce using rule 55 (expr -> primary .)
    NE              reduce using rule 55 (expr -> primary .)
    LT              reduce using rule 55 (expr -> primary .)
    GT              reduce using rule 55 (expr -> primary .)
    LE              reduce using rule 55 (expr -> primary .)
    GE              reduce using rule 55 (expr -> primary .)
    SEMICOLON       reduce using rule 55 (expr -> primary .)
    COMMA           reduce using rule 55 (expr -> primary .)
    DOT             shift and go to state 127


state 103

    (56) expr -> assign .

    RPAREN          reduce using rule 56 (expr -> assign .)
    PLUS            reduce using rule 56 (expr -> assign .)
    MINUS           reduce using rule 56 (expr -> assign .)
    TIMES           reduce using rule 56 (expr -> assign .)
    DIVIDE          reduce using rule 56 (expr -> assign .)
    AND             reduce using rule 56 (expr -> assign .)
    OR              reduce using rule 56 (expr -> assign .)
    EQ              reduce using rule 56 (expr -> assign .)
    NE              reduce using rule 56 (expr -> assign .)
    LT              reduce using rule 56 (expr -> assign .)
    GT              reduce using rule 56 (expr -> assign .)
    LE              reduce using rule 56 (expr -> assign .)
    GE              reduce using rule 56 (expr -> assign .)
    SEMICOLON       reduce using rule 56 (expr -> assign .)
    COMMA           reduce using rule 56 (expr -> assign .)


state 104

    (57) expr -> expr_arith_op .

    RPAREN          reduce using rule 57 (expr -> expr_arith_op .)
    PLUS            reduce using rule 57 (expr -> expr_arith_op .)
    MINUS           reduce using rule 57 (expr -> expr_arith_op .)
    TIMES           reduce using rule 57 (expr -> expr_arith_op .)
    DIVIDE          reduce using rule 57 (expr -> expr_arith_op .)
    AND             reduce using rule 57 (expr -> expr_arith_op .)
    OR              reduce using rule 57 (expr -> expr_arith_op .)
    EQ              reduce using rule 57 (expr -> expr_arith_op .)
    NE              reduce using rule 57 (expr -> expr_arith_op .)
    LT              reduce using rule 57 (expr -> expr_arith_op .)
    GT              reduce using rule 57 (expr -> expr_arith_op .)
    LE              reduce using rule 57 (expr -> expr_arith_op .)
    GE              reduce using rule 57 (expr -> expr_arith_op .)
    SEMICOLON       reduce using rule 57 (expr -> expr_arith_op .)
    COMMA           reduce using rule 57 (expr -> expr_arith_op .)


state 105

    (58) expr -> expr_bool_op .

    RPAREN          reduce using rule 58 (expr -> expr_bool_op .)
    PLUS            reduce using rule 58 (expr -> expr_bool_op .)
    MINUS           reduce using rule 58 (expr -> expr_bool_op .)
    TIMES           reduce using rule 58 (expr -> expr_bool_op .)
    DIVIDE          reduce using rule 58 (expr -> expr_bool_op .)
    AND             reduce using rule 58 (expr -> expr_bool_op .)
    OR              reduce using rule 58 (expr -> expr_bool_op .)
    EQ              reduce using rule 58 (expr -> expr_bool_op .)
    NE              reduce using rule 58 (expr -> expr_bool_op .)
    LT              reduce using rule 58 (expr -> expr_bool_op .)
    GT              reduce using rule 58 (expr -> expr_bool_op .)
    LE              reduce using rule 58 (expr -> expr_bool_op .)
    GE              reduce using rule 58 (expr -> expr_bool_op .)
    SEMICOLON       reduce using rule 58 (expr -> expr_bool_op .)
    COMMA           reduce using rule 58 (expr -> expr_bool_op .)


state 106

    (59) expr -> expr_unary_op .

    RPAREN          reduce using rule 59 (expr -> expr_unary_op .)
    PLUS            reduce using rule 59 (expr -> expr_unary_op .)
    MINUS           reduce using rule 59 (expr -> expr_unary_op .)
    TIMES           reduce using rule 59 (expr -> expr_unary_op .)
    DIVIDE          reduce using rule 59 (expr -> expr_unary_op .)
    AND             reduce using rule 59 (expr -> expr_unary_op .)
    OR              reduce using rule 59 (expr -> expr_unary_op .)
    EQ              reduce using rule 59 (expr -> expr_unary_op .)
    NE              reduce using rule 59 (expr -> expr_unary_op .)
    LT              reduce using rule 59 (expr -> expr_unary_op .)
    GT              reduce using rule 59 (expr -> expr_unary_op .)
    LE              reduce using rule 59 (expr -> expr_unary_op .)
    GE              reduce using rule 59 (expr -> expr_unary_op .)
    SEMICOLON       reduce using rule 59 (expr -> expr_unary_op .)
    COMMA           reduce using rule 59 (expr -> expr_unary_op .)


state 107

    (74) field_access -> ID .

    LPAREN          reduce using rule 74 (field_access -> ID .)
    EQUALS          reduce using rule 74 (field_access -> ID .)
    INCREMENT       reduce using rule 74 (field_access -> ID .)
    DECREMENT       reduce using rule 74 (field_access -> ID .)
    DOT             reduce using rule 74 (field_access -> ID .)
    RPAREN          reduce using rule 74 (field_access -> ID .)
    PLUS            reduce using rule 74 (field_access -> ID .)
    MINUS           reduce using rule 74 (field_access -> ID .)
    TIMES           reduce using rule 74 (field_access -> ID .)
    DIVIDE          reduce using rule 74 (field_access -> ID .)
    AND             reduce using rule 74 (field_access -> ID .)
    OR              reduce using rule 74 (field_access -> ID .)
    EQ              reduce using rule 74 (field_access -> ID .)
    NE              reduce using rule 74 (field_access -> ID .)
    LT              reduce using rule 74 (field_access -> ID .)
    GT              reduce using rule 74 (field_access -> ID .)
    LE              reduce using rule 74 (field_access -> ID .)
    GE              reduce using rule 74 (field_access -> ID .)
    SEMICOLON       reduce using rule 74 (field_access -> ID .)
    COMMA           reduce using rule 74 (field_access -> ID .)


state 108

    (65) primary -> lhs .
    (67) assign -> lhs . EQUALS expr
    (68) assign -> lhs . INCREMENT
    (70) assign -> lhs . DECREMENT

    DOT             reduce using rule 65 (primary -> lhs .)
    RPAREN          reduce using rule 65 (primary -> lhs .)
    PLUS            reduce using rule 65 (primary -> lhs .)
    MINUS           reduce using rule 65 (primary -> lhs .)
    TIMES           reduce using rule 65 (primary -> lhs .)
    DIVIDE          reduce using rule 65 (primary -> lhs .)
    AND             reduce using rule 65 (primary -> lhs .)
    OR              reduce using rule 65 (primary -> lhs .)
    EQ              reduce using rule 65 (primary -> lhs .)
    NE              reduce using rule 65 (primary -> lhs .)
    LT              reduce using rule 65 (primary -> lhs .)
    GT              reduce using rule 65 (primary -> lhs .)
    LE              reduce using rule 65 (primary -> lhs .)
    GE              reduce using rule 65 (primary -> lhs .)
    SEMICOLON       reduce using rule 65 (primary -> lhs .)
    COMMA           reduce using rule 65 (primary -> lhs .)
    EQUALS          shift and go to state 121
    INCREMENT       shift and go to state 122
    DECREMENT       shift and go to state 123


state 109

    (66) primary -> method_invocation .

    DOT             reduce using rule 66 (primary -> method_invocation .)
    RPAREN          reduce using rule 66 (primary -> method_invocation .)
    PLUS            reduce using rule 66 (primary -> method_invocation .)
    MINUS           reduce using rule 66 (primary -> method_invocation .)
    TIMES           reduce using rule 66 (primary -> method_invocation .)
    DIVIDE          reduce using rule 66 (primary -> method_invocation .)
    AND             reduce using rule 66 (primary -> method_invocation .)
    OR              reduce using rule 66 (primary -> method_invocation .)
    EQ              reduce using rule 66 (primary -> method_invocation .)
    NE              reduce using rule 66 (primary -> method_invocation .)
    LT              reduce using rule 66 (primary -> method_invocation .)
    GT              reduce using rule 66 (primary -> method_invocation .)
    LE              reduce using rule 66 (primary -> method_invocation .)
    GE              reduce using rule 66 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 66 (primary -> method_invocation .)
    COMMA           reduce using rule 66 (primary -> method_invocation .)


state 110

    (81) expr_unary_op -> PLUS . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 146
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 111

    (82) expr_unary_op -> MINUS . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 147
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 112

    (83) expr_unary_op -> NOT . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 148
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 113

    (72) lhs -> field_access .
    (78) method_invocation -> field_access . LPAREN arguments RPAREN

    EQUALS          reduce using rule 72 (lhs -> field_access .)
    INCREMENT       reduce using rule 72 (lhs -> field_access .)
    DECREMENT       reduce using rule 72 (lhs -> field_access .)
    DOT             reduce using rule 72 (lhs -> field_access .)
    RPAREN          reduce using rule 72 (lhs -> field_access .)
    PLUS            reduce using rule 72 (lhs -> field_access .)
    MINUS           reduce using rule 72 (lhs -> field_access .)
    TIMES           reduce using rule 72 (lhs -> field_access .)
    DIVIDE          reduce using rule 72 (lhs -> field_access .)
    AND             reduce using rule 72 (lhs -> field_access .)
    OR              reduce using rule 72 (lhs -> field_access .)
    EQ              reduce using rule 72 (lhs -> field_access .)
    NE              reduce using rule 72 (lhs -> field_access .)
    LT              reduce using rule 72 (lhs -> field_access .)
    GT              reduce using rule 72 (lhs -> field_access .)
    LE              reduce using rule 72 (lhs -> field_access .)
    GE              reduce using rule 72 (lhs -> field_access .)
    SEMICOLON       reduce using rule 72 (lhs -> field_access .)
    COMMA           reduce using rule 72 (lhs -> field_access .)
    LPAREN          shift and go to state 126


state 114

    (42) stmt -> WHILE LPAREN . expr RPAREN stmt
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 149
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 115

    (43) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> FOR LPAREN . SEMICOLON SEMICOLON RPAREN stmt
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    SEMICOLON       shift and go to state 151
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    ID              shift and go to state 107
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt_expr                      shift and go to state 150
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 116

    (47) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    LBRACE          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INCREMENT       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    DECREMENT       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    RBRACE          reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> stmt_expr SEMICOLON .)


state 117

    (45) stmt -> RETURN expr . SEMICOLON
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    SEMICOLON       shift and go to state 152
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 118

    (46) stmt -> RETURN SEMICOLON .

    IF              reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    INT_CONST       reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    FLOAT_CONST     reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    STRING_CONST    reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 46 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> RETURN SEMICOLON .)


state 119

    (48) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 48 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 48 (stmt -> BREAK SEMICOLON .)


state 120

    (49) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 49 (stmt -> CONTINUE SEMICOLON .)


state 121

    (67) assign -> lhs EQUALS . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    lhs                            shift and go to state 108
    expr                           shift and go to state 153
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 122

    (68) assign -> lhs INCREMENT .

    SEMICOLON       reduce using rule 68 (assign -> lhs INCREMENT .)
    RPAREN          reduce using rule 68 (assign -> lhs INCREMENT .)
    PLUS            reduce using rule 68 (assign -> lhs INCREMENT .)
    MINUS           reduce using rule 68 (assign -> lhs INCREMENT .)
    TIMES           reduce using rule 68 (assign -> lhs INCREMENT .)
    DIVIDE          reduce using rule 68 (assign -> lhs INCREMENT .)
    AND             reduce using rule 68 (assign -> lhs INCREMENT .)
    OR              reduce using rule 68 (assign -> lhs INCREMENT .)
    EQ              reduce using rule 68 (assign -> lhs INCREMENT .)
    NE              reduce using rule 68 (assign -> lhs INCREMENT .)
    LT              reduce using rule 68 (assign -> lhs INCREMENT .)
    GT              reduce using rule 68 (assign -> lhs INCREMENT .)
    LE              reduce using rule 68 (assign -> lhs INCREMENT .)
    GE              reduce using rule 68 (assign -> lhs INCREMENT .)
    COMMA           reduce using rule 68 (assign -> lhs INCREMENT .)


state 123

    (70) assign -> lhs DECREMENT .

    SEMICOLON       reduce using rule 70 (assign -> lhs DECREMENT .)
    RPAREN          reduce using rule 70 (assign -> lhs DECREMENT .)
    PLUS            reduce using rule 70 (assign -> lhs DECREMENT .)
    MINUS           reduce using rule 70 (assign -> lhs DECREMENT .)
    TIMES           reduce using rule 70 (assign -> lhs DECREMENT .)
    DIVIDE          reduce using rule 70 (assign -> lhs DECREMENT .)
    AND             reduce using rule 70 (assign -> lhs DECREMENT .)
    OR              reduce using rule 70 (assign -> lhs DECREMENT .)
    EQ              reduce using rule 70 (assign -> lhs DECREMENT .)
    NE              reduce using rule 70 (assign -> lhs DECREMENT .)
    LT              reduce using rule 70 (assign -> lhs DECREMENT .)
    GT              reduce using rule 70 (assign -> lhs DECREMENT .)
    LE              reduce using rule 70 (assign -> lhs DECREMENT .)
    GE              reduce using rule 70 (assign -> lhs DECREMENT .)
    COMMA           reduce using rule 70 (assign -> lhs DECREMENT .)


state 124

    (69) assign -> INCREMENT lhs .
    (65) primary -> lhs .

    SEMICOLON       reduce using rule 69 (assign -> INCREMENT lhs .)
    RPAREN          reduce using rule 69 (assign -> INCREMENT lhs .)
    PLUS            reduce using rule 69 (assign -> INCREMENT lhs .)
    MINUS           reduce using rule 69 (assign -> INCREMENT lhs .)
    TIMES           reduce using rule 69 (assign -> INCREMENT lhs .)
    DIVIDE          reduce using rule 69 (assign -> INCREMENT lhs .)
    AND             reduce using rule 69 (assign -> INCREMENT lhs .)
    OR              reduce using rule 69 (assign -> INCREMENT lhs .)
    EQ              reduce using rule 69 (assign -> INCREMENT lhs .)
    NE              reduce using rule 69 (assign -> INCREMENT lhs .)
    LT              reduce using rule 69 (assign -> INCREMENT lhs .)
    GT              reduce using rule 69 (assign -> INCREMENT lhs .)
    LE              reduce using rule 69 (assign -> INCREMENT lhs .)
    GE              reduce using rule 69 (assign -> INCREMENT lhs .)
    COMMA           reduce using rule 69 (assign -> INCREMENT lhs .)
    DOT             reduce using rule 65 (primary -> lhs .)


state 125

    (71) assign -> DECREMENT lhs .
    (65) primary -> lhs .

    SEMICOLON       reduce using rule 71 (assign -> DECREMENT lhs .)
    RPAREN          reduce using rule 71 (assign -> DECREMENT lhs .)
    PLUS            reduce using rule 71 (assign -> DECREMENT lhs .)
    MINUS           reduce using rule 71 (assign -> DECREMENT lhs .)
    TIMES           reduce using rule 71 (assign -> DECREMENT lhs .)
    DIVIDE          reduce using rule 71 (assign -> DECREMENT lhs .)
    AND             reduce using rule 71 (assign -> DECREMENT lhs .)
    OR              reduce using rule 71 (assign -> DECREMENT lhs .)
    EQ              reduce using rule 71 (assign -> DECREMENT lhs .)
    NE              reduce using rule 71 (assign -> DECREMENT lhs .)
    LT              reduce using rule 71 (assign -> DECREMENT lhs .)
    GT              reduce using rule 71 (assign -> DECREMENT lhs .)
    LE              reduce using rule 71 (assign -> DECREMENT lhs .)
    GE              reduce using rule 71 (assign -> DECREMENT lhs .)
    COMMA           reduce using rule 71 (assign -> DECREMENT lhs .)
    DOT             reduce using rule 65 (primary -> lhs .)


state 126

    (78) method_invocation -> field_access LPAREN . arguments RPAREN
    (75) arguments -> . expr
    (76) arguments -> . expr COMMA arguments
    (77) arguments -> .
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    RPAREN          reduce using rule 77 (arguments -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    field_access                   shift and go to state 113
    arguments                      shift and go to state 154
    expr                           shift and go to state 155
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109

state 127

    (73) field_access -> primary DOT . ID

    ID              shift and go to state 156


state 128

    (64) primary -> NEW ID . LPAREN arguments RPAREN

    LPAREN          shift and go to state 157


state 129

    (16) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 16 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 130

    (40) stmt -> IF LPAREN expr . RPAREN stmt
    (41) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          shift and go to state 158
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 131

    (63) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    EQ              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    NE              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    LT              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    GT              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    LE              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    GE              reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 63 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 63 (primary -> LPAREN expr RPAREN .)


state 132

    (79) expr_arith_op -> expr arith_op . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 159
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 133

    (80) expr_bool_op -> expr bool_op . expr
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 160
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 134

    (90) arith_op -> PLUS .

    THIS            reduce using rule 90 (arith_op -> PLUS .)
    SUPER           reduce using rule 90 (arith_op -> PLUS .)
    LPAREN          reduce using rule 90 (arith_op -> PLUS .)
    NEW             reduce using rule 90 (arith_op -> PLUS .)
    INCREMENT       reduce using rule 90 (arith_op -> PLUS .)
    DECREMENT       reduce using rule 90 (arith_op -> PLUS .)
    PLUS            reduce using rule 90 (arith_op -> PLUS .)
    MINUS           reduce using rule 90 (arith_op -> PLUS .)
    NOT             reduce using rule 90 (arith_op -> PLUS .)
    INT_CONST       reduce using rule 90 (arith_op -> PLUS .)
    FLOAT_CONST     reduce using rule 90 (arith_op -> PLUS .)
    STRING_CONST    reduce using rule 90 (arith_op -> PLUS .)
    NULL            reduce using rule 90 (arith_op -> PLUS .)
    TRUE            reduce using rule 90 (arith_op -> PLUS .)
    FALSE           reduce using rule 90 (arith_op -> PLUS .)
    ID              reduce using rule 90 (arith_op -> PLUS .)


state 135

    (91) arith_op -> MINUS .

    THIS            reduce using rule 91 (arith_op -> MINUS .)
    SUPER           reduce using rule 91 (arith_op -> MINUS .)
    LPAREN          reduce using rule 91 (arith_op -> MINUS .)
    NEW             reduce using rule 91 (arith_op -> MINUS .)
    INCREMENT       reduce using rule 91 (arith_op -> MINUS .)
    DECREMENT       reduce using rule 91 (arith_op -> MINUS .)
    PLUS            reduce using rule 91 (arith_op -> MINUS .)
    MINUS           reduce using rule 91 (arith_op -> MINUS .)
    NOT             reduce using rule 91 (arith_op -> MINUS .)
    INT_CONST       reduce using rule 91 (arith_op -> MINUS .)
    FLOAT_CONST     reduce using rule 91 (arith_op -> MINUS .)
    STRING_CONST    reduce using rule 91 (arith_op -> MINUS .)
    NULL            reduce using rule 91 (arith_op -> MINUS .)
    TRUE            reduce using rule 91 (arith_op -> MINUS .)
    FALSE           reduce using rule 91 (arith_op -> MINUS .)
    ID              reduce using rule 91 (arith_op -> MINUS .)


state 136

    (92) arith_op -> TIMES .

    THIS            reduce using rule 92 (arith_op -> TIMES .)
    SUPER           reduce using rule 92 (arith_op -> TIMES .)
    LPAREN          reduce using rule 92 (arith_op -> TIMES .)
    NEW             reduce using rule 92 (arith_op -> TIMES .)
    INCREMENT       reduce using rule 92 (arith_op -> TIMES .)
    DECREMENT       reduce using rule 92 (arith_op -> TIMES .)
    PLUS            reduce using rule 92 (arith_op -> TIMES .)
    MINUS           reduce using rule 92 (arith_op -> TIMES .)
    NOT             reduce using rule 92 (arith_op -> TIMES .)
    INT_CONST       reduce using rule 92 (arith_op -> TIMES .)
    FLOAT_CONST     reduce using rule 92 (arith_op -> TIMES .)
    STRING_CONST    reduce using rule 92 (arith_op -> TIMES .)
    NULL            reduce using rule 92 (arith_op -> TIMES .)
    TRUE            reduce using rule 92 (arith_op -> TIMES .)
    FALSE           reduce using rule 92 (arith_op -> TIMES .)
    ID              reduce using rule 92 (arith_op -> TIMES .)


state 137

    (93) arith_op -> DIVIDE .

    THIS            reduce using rule 93 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 93 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 93 (arith_op -> DIVIDE .)
    NEW             reduce using rule 93 (arith_op -> DIVIDE .)
    INCREMENT       reduce using rule 93 (arith_op -> DIVIDE .)
    DECREMENT       reduce using rule 93 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 93 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 93 (arith_op -> DIVIDE .)
    NOT             reduce using rule 93 (arith_op -> DIVIDE .)
    INT_CONST       reduce using rule 93 (arith_op -> DIVIDE .)
    FLOAT_CONST     reduce using rule 93 (arith_op -> DIVIDE .)
    STRING_CONST    reduce using rule 93 (arith_op -> DIVIDE .)
    NULL            reduce using rule 93 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 93 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 93 (arith_op -> DIVIDE .)
    ID              reduce using rule 93 (arith_op -> DIVIDE .)


state 138

    (94) bool_op -> AND .

    THIS            reduce using rule 94 (bool_op -> AND .)
    SUPER           reduce using rule 94 (bool_op -> AND .)
    LPAREN          reduce using rule 94 (bool_op -> AND .)
    NEW             reduce using rule 94 (bool_op -> AND .)
    INCREMENT       reduce using rule 94 (bool_op -> AND .)
    DECREMENT       reduce using rule 94 (bool_op -> AND .)
    PLUS            reduce using rule 94 (bool_op -> AND .)
    MINUS           reduce using rule 94 (bool_op -> AND .)
    NOT             reduce using rule 94 (bool_op -> AND .)
    INT_CONST       reduce using rule 94 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 94 (bool_op -> AND .)
    STRING_CONST    reduce using rule 94 (bool_op -> AND .)
    NULL            reduce using rule 94 (bool_op -> AND .)
    TRUE            reduce using rule 94 (bool_op -> AND .)
    FALSE           reduce using rule 94 (bool_op -> AND .)
    ID              reduce using rule 94 (bool_op -> AND .)


state 139

    (95) bool_op -> OR .

    THIS            reduce using rule 95 (bool_op -> OR .)
    SUPER           reduce using rule 95 (bool_op -> OR .)
    LPAREN          reduce using rule 95 (bool_op -> OR .)
    NEW             reduce using rule 95 (bool_op -> OR .)
    INCREMENT       reduce using rule 95 (bool_op -> OR .)
    DECREMENT       reduce using rule 95 (bool_op -> OR .)
    PLUS            reduce using rule 95 (bool_op -> OR .)
    MINUS           reduce using rule 95 (bool_op -> OR .)
    NOT             reduce using rule 95 (bool_op -> OR .)
    INT_CONST       reduce using rule 95 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 95 (bool_op -> OR .)
    STRING_CONST    reduce using rule 95 (bool_op -> OR .)
    NULL            reduce using rule 95 (bool_op -> OR .)
    TRUE            reduce using rule 95 (bool_op -> OR .)
    FALSE           reduce using rule 95 (bool_op -> OR .)
    ID              reduce using rule 95 (bool_op -> OR .)


state 140

    (96) bool_op -> EQ .

    THIS            reduce using rule 96 (bool_op -> EQ .)
    SUPER           reduce using rule 96 (bool_op -> EQ .)
    LPAREN          reduce using rule 96 (bool_op -> EQ .)
    NEW             reduce using rule 96 (bool_op -> EQ .)
    INCREMENT       reduce using rule 96 (bool_op -> EQ .)
    DECREMENT       reduce using rule 96 (bool_op -> EQ .)
    PLUS            reduce using rule 96 (bool_op -> EQ .)
    MINUS           reduce using rule 96 (bool_op -> EQ .)
    NOT             reduce using rule 96 (bool_op -> EQ .)
    INT_CONST       reduce using rule 96 (bool_op -> EQ .)
    FLOAT_CONST     reduce using rule 96 (bool_op -> EQ .)
    STRING_CONST    reduce using rule 96 (bool_op -> EQ .)
    NULL            reduce using rule 96 (bool_op -> EQ .)
    TRUE            reduce using rule 96 (bool_op -> EQ .)
    FALSE           reduce using rule 96 (bool_op -> EQ .)
    ID              reduce using rule 96 (bool_op -> EQ .)


state 141

    (97) bool_op -> NE .

    THIS            reduce using rule 97 (bool_op -> NE .)
    SUPER           reduce using rule 97 (bool_op -> NE .)
    LPAREN          reduce using rule 97 (bool_op -> NE .)
    NEW             reduce using rule 97 (bool_op -> NE .)
    INCREMENT       reduce using rule 97 (bool_op -> NE .)
    DECREMENT       reduce using rule 97 (bool_op -> NE .)
    PLUS            reduce using rule 97 (bool_op -> NE .)
    MINUS           reduce using rule 97 (bool_op -> NE .)
    NOT             reduce using rule 97 (bool_op -> NE .)
    INT_CONST       reduce using rule 97 (bool_op -> NE .)
    FLOAT_CONST     reduce using rule 97 (bool_op -> NE .)
    STRING_CONST    reduce using rule 97 (bool_op -> NE .)
    NULL            reduce using rule 97 (bool_op -> NE .)
    TRUE            reduce using rule 97 (bool_op -> NE .)
    FALSE           reduce using rule 97 (bool_op -> NE .)
    ID              reduce using rule 97 (bool_op -> NE .)


state 142

    (98) bool_op -> LT .

    THIS            reduce using rule 98 (bool_op -> LT .)
    SUPER           reduce using rule 98 (bool_op -> LT .)
    LPAREN          reduce using rule 98 (bool_op -> LT .)
    NEW             reduce using rule 98 (bool_op -> LT .)
    INCREMENT       reduce using rule 98 (bool_op -> LT .)
    DECREMENT       reduce using rule 98 (bool_op -> LT .)
    PLUS            reduce using rule 98 (bool_op -> LT .)
    MINUS           reduce using rule 98 (bool_op -> LT .)
    NOT             reduce using rule 98 (bool_op -> LT .)
    INT_CONST       reduce using rule 98 (bool_op -> LT .)
    FLOAT_CONST     reduce using rule 98 (bool_op -> LT .)
    STRING_CONST    reduce using rule 98 (bool_op -> LT .)
    NULL            reduce using rule 98 (bool_op -> LT .)
    TRUE            reduce using rule 98 (bool_op -> LT .)
    FALSE           reduce using rule 98 (bool_op -> LT .)
    ID              reduce using rule 98 (bool_op -> LT .)


state 143

    (99) bool_op -> GT .

    THIS            reduce using rule 99 (bool_op -> GT .)
    SUPER           reduce using rule 99 (bool_op -> GT .)
    LPAREN          reduce using rule 99 (bool_op -> GT .)
    NEW             reduce using rule 99 (bool_op -> GT .)
    INCREMENT       reduce using rule 99 (bool_op -> GT .)
    DECREMENT       reduce using rule 99 (bool_op -> GT .)
    PLUS            reduce using rule 99 (bool_op -> GT .)
    MINUS           reduce using rule 99 (bool_op -> GT .)
    NOT             reduce using rule 99 (bool_op -> GT .)
    INT_CONST       reduce using rule 99 (bool_op -> GT .)
    FLOAT_CONST     reduce using rule 99 (bool_op -> GT .)
    STRING_CONST    reduce using rule 99 (bool_op -> GT .)
    NULL            reduce using rule 99 (bool_op -> GT .)
    TRUE            reduce using rule 99 (bool_op -> GT .)
    FALSE           reduce using rule 99 (bool_op -> GT .)
    ID              reduce using rule 99 (bool_op -> GT .)


state 144

    (100) bool_op -> LE .

    THIS            reduce using rule 100 (bool_op -> LE .)
    SUPER           reduce using rule 100 (bool_op -> LE .)
    LPAREN          reduce using rule 100 (bool_op -> LE .)
    NEW             reduce using rule 100 (bool_op -> LE .)
    INCREMENT       reduce using rule 100 (bool_op -> LE .)
    DECREMENT       reduce using rule 100 (bool_op -> LE .)
    PLUS            reduce using rule 100 (bool_op -> LE .)
    MINUS           reduce using rule 100 (bool_op -> LE .)
    NOT             reduce using rule 100 (bool_op -> LE .)
    INT_CONST       reduce using rule 100 (bool_op -> LE .)
    FLOAT_CONST     reduce using rule 100 (bool_op -> LE .)
    STRING_CONST    reduce using rule 100 (bool_op -> LE .)
    NULL            reduce using rule 100 (bool_op -> LE .)
    TRUE            reduce using rule 100 (bool_op -> LE .)
    FALSE           reduce using rule 100 (bool_op -> LE .)
    ID              reduce using rule 100 (bool_op -> LE .)


state 145

    (101) bool_op -> GE .

    THIS            reduce using rule 101 (bool_op -> GE .)
    SUPER           reduce using rule 101 (bool_op -> GE .)
    LPAREN          reduce using rule 101 (bool_op -> GE .)
    NEW             reduce using rule 101 (bool_op -> GE .)
    INCREMENT       reduce using rule 101 (bool_op -> GE .)
    DECREMENT       reduce using rule 101 (bool_op -> GE .)
    PLUS            reduce using rule 101 (bool_op -> GE .)
    MINUS           reduce using rule 101 (bool_op -> GE .)
    NOT             reduce using rule 101 (bool_op -> GE .)
    INT_CONST       reduce using rule 101 (bool_op -> GE .)
    FLOAT_CONST     reduce using rule 101 (bool_op -> GE .)
    STRING_CONST    reduce using rule 101 (bool_op -> GE .)
    NULL            reduce using rule 101 (bool_op -> GE .)
    TRUE            reduce using rule 101 (bool_op -> GE .)
    FALSE           reduce using rule 101 (bool_op -> GE .)
    ID              reduce using rule 101 (bool_op -> GE .)


state 146

    (81) expr_unary_op -> PLUS expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          reduce using rule 81 (expr_unary_op -> PLUS expr .)
    PLUS            reduce using rule 81 (expr_unary_op -> PLUS expr .)
    MINUS           reduce using rule 81 (expr_unary_op -> PLUS expr .)
    TIMES           reduce using rule 81 (expr_unary_op -> PLUS expr .)
    DIVIDE          reduce using rule 81 (expr_unary_op -> PLUS expr .)
    AND             reduce using rule 81 (expr_unary_op -> PLUS expr .)
    OR              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    EQ              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    NE              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    LT              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    GT              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    LE              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    GE              reduce using rule 81 (expr_unary_op -> PLUS expr .)
    SEMICOLON       reduce using rule 81 (expr_unary_op -> PLUS expr .)
    COMMA           reduce using rule 81 (expr_unary_op -> PLUS expr .)

  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 135 ]
  ! TIMES           [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 137 ]
  ! AND             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 139 ]
  ! EQ              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 141 ]
  ! LT              [ shift and go to state 142 ]
  ! GT              [ shift and go to state 143 ]
  ! LE              [ shift and go to state 144 ]
  ! GE              [ shift and go to state 145 ]

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 147

    (82) expr_unary_op -> MINUS expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          reduce using rule 82 (expr_unary_op -> MINUS expr .)
    PLUS            reduce using rule 82 (expr_unary_op -> MINUS expr .)
    MINUS           reduce using rule 82 (expr_unary_op -> MINUS expr .)
    TIMES           reduce using rule 82 (expr_unary_op -> MINUS expr .)
    DIVIDE          reduce using rule 82 (expr_unary_op -> MINUS expr .)
    AND             reduce using rule 82 (expr_unary_op -> MINUS expr .)
    OR              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    EQ              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    NE              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    LT              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    GT              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    LE              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    GE              reduce using rule 82 (expr_unary_op -> MINUS expr .)
    SEMICOLON       reduce using rule 82 (expr_unary_op -> MINUS expr .)
    COMMA           reduce using rule 82 (expr_unary_op -> MINUS expr .)

  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 135 ]
  ! TIMES           [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 137 ]
  ! AND             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 139 ]
  ! EQ              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 141 ]
  ! LT              [ shift and go to state 142 ]
  ! GT              [ shift and go to state 143 ]
  ! LE              [ shift and go to state 144 ]
  ! GE              [ shift and go to state 145 ]

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 148

    (83) expr_unary_op -> NOT expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          reduce using rule 83 (expr_unary_op -> NOT expr .)
    PLUS            reduce using rule 83 (expr_unary_op -> NOT expr .)
    MINUS           reduce using rule 83 (expr_unary_op -> NOT expr .)
    TIMES           reduce using rule 83 (expr_unary_op -> NOT expr .)
    DIVIDE          reduce using rule 83 (expr_unary_op -> NOT expr .)
    AND             reduce using rule 83 (expr_unary_op -> NOT expr .)
    OR              reduce using rule 83 (expr_unary_op -> NOT expr .)
    EQ              reduce using rule 83 (expr_unary_op -> NOT expr .)
    NE              reduce using rule 83 (expr_unary_op -> NOT expr .)
    LT              reduce using rule 83 (expr_unary_op -> NOT expr .)
    GT              reduce using rule 83 (expr_unary_op -> NOT expr .)
    LE              reduce using rule 83 (expr_unary_op -> NOT expr .)
    GE              reduce using rule 83 (expr_unary_op -> NOT expr .)
    SEMICOLON       reduce using rule 83 (expr_unary_op -> NOT expr .)
    COMMA           reduce using rule 83 (expr_unary_op -> NOT expr .)

  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 135 ]
  ! TIMES           [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 137 ]
  ! AND             [ shift and go to state 138 ]
  ! OR              [ shift and go to state 139 ]
  ! EQ              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 141 ]
  ! LT              [ shift and go to state 142 ]
  ! GT              [ shift and go to state 143 ]
  ! LE              [ shift and go to state 144 ]
  ! GE              [ shift and go to state 145 ]

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 149

    (42) stmt -> WHILE LPAREN expr . RPAREN stmt
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          shift and go to state 161
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 150

    (43) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 162


state 151

    (44) stmt -> FOR LPAREN SEMICOLON . SEMICOLON RPAREN stmt

    SEMICOLON       shift and go to state 163


state 152

    (45) stmt -> RETURN expr SEMICOLON .

    IF              reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    DECREMENT       reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    INT_CONST       reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    STRING_CONST    reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> RETURN expr SEMICOLON .)


state 153

    (67) assign -> lhs EQUALS expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    SEMICOLON       reduce using rule 67 (assign -> lhs EQUALS expr .)
    RPAREN          reduce using rule 67 (assign -> lhs EQUALS expr .)
    COMMA           reduce using rule 67 (assign -> lhs EQUALS expr .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

  ! PLUS            [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! MINUS           [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! TIMES           [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! AND             [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! OR              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! EQ              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! NE              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! LT              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! GT              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! LE              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]
  ! GE              [ reduce using rule 67 (assign -> lhs EQUALS expr .) ]

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 154

    (78) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 164


state 155

    (75) arguments -> expr .
    (76) arguments -> expr . COMMA arguments
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    RPAREN          reduce using rule 75 (arguments -> expr .)
    COMMA           shift and go to state 165
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 156

    (73) field_access -> primary DOT ID .

    LPAREN          reduce using rule 73 (field_access -> primary DOT ID .)
    EQUALS          reduce using rule 73 (field_access -> primary DOT ID .)
    INCREMENT       reduce using rule 73 (field_access -> primary DOT ID .)
    DECREMENT       reduce using rule 73 (field_access -> primary DOT ID .)
    DOT             reduce using rule 73 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 73 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 73 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 73 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 73 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 73 (field_access -> primary DOT ID .)
    AND             reduce using rule 73 (field_access -> primary DOT ID .)
    OR              reduce using rule 73 (field_access -> primary DOT ID .)
    EQ              reduce using rule 73 (field_access -> primary DOT ID .)
    NE              reduce using rule 73 (field_access -> primary DOT ID .)
    LT              reduce using rule 73 (field_access -> primary DOT ID .)
    GT              reduce using rule 73 (field_access -> primary DOT ID .)
    LE              reduce using rule 73 (field_access -> primary DOT ID .)
    GE              reduce using rule 73 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 73 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 73 (field_access -> primary DOT ID .)


state 157

    (64) primary -> NEW ID LPAREN . arguments RPAREN
    (75) arguments -> . expr
    (76) arguments -> . expr COMMA arguments
    (77) arguments -> .
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    RPAREN          reduce using rule 77 (arguments -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    arguments                      shift and go to state 166
    expr                           shift and go to state 155
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 158

    (40) stmt -> IF LPAREN expr RPAREN . stmt
    (41) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt                           shift and go to state 167
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 159

    (79) expr_arith_op -> expr arith_op expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RPAREN          reduce using rule 79 (expr_arith_op -> expr arith_op expr .)
    SEMICOLON       reduce using rule 79 (expr_arith_op -> expr arith_op expr .)
    COMMA           reduce using rule 79 (expr_arith_op -> expr arith_op expr .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

  ! PLUS            [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! EQ              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! NE              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! LT              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! GT              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! LE              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]
  ! GE              [ reduce using rule 79 (expr_arith_op -> expr arith_op expr .) ]

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 160

    (80) expr_bool_op -> expr bool_op expr .
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    RPAREN          reduce using rule 80 (expr_bool_op -> expr bool_op expr .)
    SEMICOLON       reduce using rule 80 (expr_bool_op -> expr bool_op expr .)
    COMMA           reduce using rule 80 (expr_bool_op -> expr bool_op expr .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

  ! PLUS            [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! EQ              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! NE              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! LT              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! GT              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! LE              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]
  ! GE              [ reduce using rule 80 (expr_bool_op -> expr bool_op expr .) ]

    bool_op                        shift and go to state 133
    arith_op                       shift and go to state 132

state 161

    (42) stmt -> WHILE LPAREN expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt                           shift and go to state 168
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 162

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 169
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 163

    (44) stmt -> FOR LPAREN SEMICOLON SEMICOLON . RPAREN stmt

    RPAREN          shift and go to state 170


state 164

    (78) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQ              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NE              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LT              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GT              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LE              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GE              reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 78 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 165

    (76) arguments -> expr COMMA . arguments
    (75) arguments -> . expr
    (76) arguments -> . expr COMMA arguments
    (77) arguments -> .
    (55) expr -> . primary
    (56) expr -> . assign
    (57) expr -> . expr_arith_op
    (58) expr -> . expr_bool_op
    (59) expr -> . expr_unary_op
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (79) expr_arith_op -> . expr arith_op expr
    (80) expr_bool_op -> . expr bool_op expr
    (81) expr_unary_op -> . PLUS expr
    (82) expr_unary_op -> . MINUS expr
    (83) expr_unary_op -> . NOT expr
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE
    (72) lhs -> . field_access
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID

    RPAREN          reduce using rule 77 (arguments -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    PLUS            shift and go to state 110
    MINUS           shift and go to state 111
    NOT             shift and go to state 112
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93
    ID              shift and go to state 107

    expr                           shift and go to state 155
    arguments                      shift and go to state 171
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    expr_arith_op                  shift and go to state 104
    expr_bool_op                   shift and go to state 105
    expr_unary_op                  shift and go to state 106
    literal                        shift and go to state 84
    lhs                            shift and go to state 108
    method_invocation              shift and go to state 109
    field_access                   shift and go to state 113

state 166

    (64) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 172


state 167

    (40) stmt -> IF LPAREN expr RPAREN stmt .
    (41) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    INCREMENT       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    DECREMENT       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 173

  ! ELSE            [ reduce using rule 40 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 168

    (42) stmt -> WHILE LPAREN expr RPAREN stmt .

    IF              reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INCREMENT       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    DECREMENT       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 42 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 169

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (79) expr_arith_op -> expr . arith_op expr
    (80) expr_bool_op -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQ
    (97) bool_op -> . NE
    (98) bool_op -> . LT
    (99) bool_op -> . GT
    (100) bool_op -> . LE
    (101) bool_op -> . GE

    SEMICOLON       shift and go to state 174
    PLUS            shift and go to state 134
    MINUS           shift and go to state 135
    TIMES           shift and go to state 136
    DIVIDE          shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139
    EQ              shift and go to state 140
    NE              shift and go to state 141
    LT              shift and go to state 142
    GT              shift and go to state 143
    LE              shift and go to state 144
    GE              shift and go to state 145

    arith_op                       shift and go to state 132
    bool_op                        shift and go to state 133

state 170

    (44) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt                           shift and go to state 175
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 171

    (76) arguments -> expr COMMA arguments .

    RPAREN          reduce using rule 76 (arguments -> expr COMMA arguments .)


state 172

    (64) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQ              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    NE              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    LT              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    GT              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    LE              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    GE              reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 64 (primary -> NEW ID LPAREN arguments RPAREN .)


state 173

    (41) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt                           shift and go to state 176
    stmt_expr                      shift and go to state 68
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 174

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    ID              shift and go to state 107
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt_expr                      shift and go to state 177
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 175

    (44) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .

    IF              reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LBRACE          reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INCREMENT       reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    DECREMENT       reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ID              reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INT_CONST       reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT_CONST     reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    STRING_CONST    reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RBRACE          reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 44 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)


state 176

    (41) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    IF              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INCREMENT       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DECREMENT       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT_CONST       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 177

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 178


state 178

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (40) stmt -> . IF LPAREN expr RPAREN stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (42) stmt -> . WHILE LPAREN expr RPAREN stmt
    (43) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (44) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (45) stmt -> . RETURN expr SEMICOLON
    (46) stmt -> . RETURN SEMICOLON
    (47) stmt -> . stmt_expr SEMICOLON
    (48) stmt -> . BREAK SEMICOLON
    (49) stmt -> . CONTINUE SEMICOLON
    (50) stmt -> . block
    (51) stmt -> . var_decl
    (52) stmt -> . SEMICOLON
    (53) stmt_expr -> . assign
    (54) stmt_expr -> . method_invocation
    (37) block -> . LBRACE stmts RBRACE
    (26) var_decl -> . type variables SEMICOLON
    (67) assign -> . lhs EQUALS expr
    (68) assign -> . lhs INCREMENT
    (69) assign -> . INCREMENT lhs
    (70) assign -> . lhs DECREMENT
    (71) assign -> . DECREMENT lhs
    (78) method_invocation -> . field_access LPAREN arguments RPAREN
    (27) type -> . INT
    (28) type -> . FLOAT
    (29) type -> . BOOLEAN
    (30) type -> . ID
    (72) lhs -> . field_access
    (73) field_access -> . primary DOT ID
    (74) field_access -> . ID
    (60) primary -> . literal
    (61) primary -> . THIS
    (62) primary -> . SUPER
    (63) primary -> . LPAREN expr RPAREN
    (64) primary -> . NEW ID LPAREN arguments RPAREN
    (65) primary -> . lhs
    (66) primary -> . method_invocation
    (84) literal -> . INT_CONST
    (85) literal -> . FLOAT_CONST
    (86) literal -> . STRING_CONST
    (87) literal -> . NULL
    (88) literal -> . TRUE
    (89) literal -> . FALSE

    IF              shift and go to state 64
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 70
    BREAK           shift and go to state 71
    CONTINUE        shift and go to state 72
    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 53
    INCREMENT       shift and go to state 79
    DECREMENT       shift and go to state 80
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 65
    NEW             shift and go to state 87
    INT_CONST       shift and go to state 88
    FLOAT_CONST     shift and go to state 89
    STRING_CONST    shift and go to state 90
    NULL            shift and go to state 91
    TRUE            shift and go to state 92
    FALSE           shift and go to state 93

    stmt_expr                      shift and go to state 68
    stmt                           shift and go to state 179
    block                          shift and go to state 73
    var_decl                       shift and go to state 74
    assign                         shift and go to state 75
    method_invocation              shift and go to state 76
    type                           shift and go to state 77
    lhs                            shift and go to state 78
    field_access                   shift and go to state 81
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 179

    (43) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LBRACE          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INCREMENT       reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    DECREMENT       reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ID              reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT_CONST       reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    STRING_CONST    reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RBRACE          reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 159 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 159 resolved as shift
WARNING: shift/reduce conflict for AND in state 159 resolved as shift
WARNING: shift/reduce conflict for OR in state 159 resolved as shift
WARNING: shift/reduce conflict for EQ in state 159 resolved as shift
WARNING: shift/reduce conflict for NE in state 159 resolved as shift
WARNING: shift/reduce conflict for LT in state 159 resolved as shift
WARNING: shift/reduce conflict for GT in state 159 resolved as shift
WARNING: shift/reduce conflict for LE in state 159 resolved as shift
WARNING: shift/reduce conflict for GE in state 159 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 160 resolved as shift
WARNING: shift/reduce conflict for AND in state 160 resolved as shift
WARNING: shift/reduce conflict for OR in state 160 resolved as shift
WARNING: shift/reduce conflict for EQ in state 160 resolved as shift
WARNING: shift/reduce conflict for NE in state 160 resolved as shift
WARNING: shift/reduce conflict for LT in state 160 resolved as shift
WARNING: shift/reduce conflict for GT in state 160 resolved as shift
WARNING: shift/reduce conflict for LE in state 160 resolved as shift
WARNING: shift/reduce conflict for GE in state 160 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 167 resolved as shift
